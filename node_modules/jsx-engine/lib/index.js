"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.__express = exports.renderFile = void 0;
const vm_1 = __importDefault(require("vm"));
const fs_1 = require("fs");
const util_1 = require("util");
const path_1 = require("path");
const core_1 = require("@babel/core");
const jsx_1 = __importDefault(require("./jsx"));
const read = util_1.promisify(fs_1.readFile);
const cache = {};
const babelOptions = {
    plugins: [
        "@babel/plugin-transform-modules-commonjs",
        [
            "@babel/plugin-transform-react-jsx",
            {
                pragma: "jsx",
                pragmaFrag: "jsx.Fragment",
            },
        ],
    ],
};
const extensionsToLookFor = ["jsx", "js"];
function findFile(path) {
    if (path_1.parse(path).ext.length > 0) {
        return path;
    }
    for (let i = 0; i < extensionsToLookFor.length; i++) {
        const _path = `${path}.${extensionsToLookFor[i]}`;
        if (fs_1.existsSync(_path)) {
            return _path;
        }
    }
    return path;
}
const vmRequire = (_path) => (path) => {
    /* istanbul ignore if  */
    if (!_path || typeof _path !== "string") {
        throw new Error("Cannot not require without a proper path.");
    }
    if (!path.startsWith(".")) {
        return require(path);
    }
    const modPath = path_1.join(_path, path);
    const _code = fs_1.readFileSync(findFile(modPath)).toString();
    const result = core_1.transformSync(_code, babelOptions);
    /* istanbul ignore if  */
    if (!result || result === null) {
        throw new Error(`Could not parse file: ${modPath}`);
    }
    const { code } = result;
    /* istanbul ignore if  */
    if (!code || code === null) {
        throw new Error(`Could not parse file: ${modPath}`);
    }
    const vmModule = {
        exports: {},
    };
    const context = vm_1.default.createContext({
        module: vmModule,
        jsx: jsx_1.default,
        require: vmRequire(path_1.dirname(modPath)),
        exports: vmModule.exports,
    });
    vm_1.default.runInContext(code, context);
    return context.module.exports;
};
async function compile(_code, _path) {
    try {
        const r = await core_1.transform(_code, babelOptions);
        /* istanbul ignore if  */
        if (!r || r === null) {
            throw new Error(`Could not parse file: ${_path}`);
        }
        const { code } = r;
        /* istanbul ignore if  */
        if (!code || code === null) {
            throw new Error(`Could not parse file: ${_path}`);
        }
        const vmModule = {
            exports: {},
        };
        const context = vm_1.default.createContext({
            module: vmModule,
            jsx: jsx_1.default,
            require: _path ? vmRequire(path_1.dirname(_path)) : () => void 0,
            exports: vmModule.exports,
        });
        vm_1.default.runInContext(code, context);
        let f;
        if (context.module &&
            context.module.exports &&
            typeof context.module.exports === "function") {
            f = context.module.exports;
        }
        if (context.exports &&
            context.exports.__esModule === true &&
            typeof context.exports.default === "function") {
            f = context.exports.default;
        }
        if (!f) {
            throw new Error("JSX file must return a function");
        }
        return f;
    }
    catch (e) {
        throw e;
    }
}
function jsxEngine(f, locals = {}) {
    return jsx_1.default.render(f(locals));
}
async function render(code, locals = {}, path, callback) {
    let f;
    /* istanbul ignore if  */
    if (path &&
        cache[path] &&
        ((locals &&
            locals.settings &&
            locals.settings["view cache"] &&
            locals.settings["view cache"] === true) ||
            (locals && locals.cache && locals.cache === true))) {
        f = cache[path];
    }
    else {
        try {
            f = await compile(code, path);
            if (path) {
                // eslint-disable-next-line require-atomic-updates
                cache[path] = f;
            }
        }
        catch (e) {
            /* istanbul ignore if  */
            if (callback) {
                callback(e);
            }
            throw e;
        }
    }
    const html = jsxEngine(f, locals);
    if (callback) {
        callback(undefined, html);
    }
    return html;
}
async function renderFile(path, locals = {}, callback) {
    return render((await read(path)).toString(), locals, path, callback);
}
exports.renderFile = renderFile;
renderFile.__express = renderFile;
renderFile.render = render;
module.exports = renderFile;
// eslint-disable-next-line @typescript-eslint/naming-convention
exports.__express = renderFile;
exports.default = renderFile;
